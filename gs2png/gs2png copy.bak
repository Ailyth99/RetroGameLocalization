package main

import (
	"encoding/binary"
	"fmt"
	"image"
	"image/color"
	"image/png"
	"os"
	"path/filepath"
)

type GSHeader struct {
	Magic     [2]byte
	ImageType uint16
	Width     uint16
	Height    uint16
	MipmapNum uint16
	Padding   [6]byte
}

func convertGStoPNG(gsPath, pngPath string) error {
	// 读取GS文件
	gsFile, err := os.Open(gsPath)
	if err != nil {
		return fmt.Errorf("无法打开GS文件呢: %v", err)
	}
	defer gsFile.Close()

	// 读取头部信息
	var header GSHeader
	if err := binary.Read(gsFile, binary.LittleEndian, &header); err != nil {
		return fmt.Errorf("读取文件头失败了: %v", err)
	}

	if string(header.Magic[:]) != "GS" {
		return fmt.Errorf("这不是GS文件呢")
	}

	width, height := int(header.Width), int(header.Height)

	// 读取调色板
	gsFile.Seek(0x10, 0) // 跳到调色板位置
	var palette color.Palette
	paletteSize := 16
	if header.ImageType == 0x13 {
		paletteSize = 256
	}

	for i := 0; i < paletteSize; i++ {
		rgba := make([]byte, 4)
		gsFile.Read(rgba)
		r, g, b, a := rgba[0], rgba[1], rgba[2], rgba[3]

		// 4bpp模式下只保留纯黑色的透明度
		if header.ImageType == 0x14 {
			if r == 0 && g == 0 && b == 0 {
				a = 0x00
			} else {
				a = 0xFF
			}
		} else {
			// 8bpp模式下取消所有透明度
			a = 0xFF
		}

		palette = append(palette, color.NRGBA{r, g, b, a})
	}

	// 创建新图像
	img := image.NewPaletted(image.Rect(0, 0, width, height), palette)

	// 读取像素数据
	gsFile.Seek(0x50, 0)
	if header.ImageType == 0x13 { // 8bpp
		raw_data := make([]byte, width*height)
		gsFile.Read(raw_data)

		if width <= 64 {
			// 小图直接复制数据
			copy(img.Pix, raw_data)
		} else {
			// 大图需要特殊处理
			half_width := width / 2
			for y := 0; y < height; y++ {
				for x := 0; x < half_width; x++ {
					// 处理左半边
					src_pos := (y+1)%height*width + x
					dst_pos := y*width + (x + half_width)
					img.Pix[dst_pos] = raw_data[src_pos]

					// 处理右半边
					src_pos = y*width + (x + half_width)
					dst_pos = y*width + x
					img.Pix[dst_pos] = raw_data[src_pos]
				}
			}
		}
	} else { // 4bpp
		raw_data := make([]byte, (width*height)/2)
		gsFile.Read(raw_data)

		pixelIdx := 0
		for y := 0; y < height; y++ {
			rowStart := y * (width / 2)
			for x := 0; x < width; x += 2 {
				b := raw_data[rowStart+x/2]
				// 注意这里改变了解析顺序
				low := (b & 0x0F)
				high := (b & 0xF0) >> 4
				// 先放high再放low
				img.Pix[y*width+x] = low
				if x+1 < width {
					img.Pix[y*width+x+1] = high
				}
				pixelIdx++
			}
		}
	}

	// 保存为PNG
	outFile, err := os.Create(pngPath)
	if err != nil {
		return fmt.Errorf("无法创建输出文件呢: %v", err)
	}
	defer outFile.Close()

	if err := png.Encode(outFile, img); err != nil {
		return fmt.Errorf("保存PNG失败了: %v", err)
	}

	return nil
}

func main() {
	if len(os.Args) != 2 {
		fmt.Println("使用方法: gs2png <gs文件路径>")
		return
	}

	gsPath := os.Args[1]
	pngPath := filepath.Join(filepath.Dir(gsPath),
		filepath.Base(gsPath[:len(gsPath)-len(filepath.Ext(gsPath))])+".png")

	if err := convertGStoPNG(gsPath, pngPath); err != nil {
		fmt.Printf("转换失败了呢: %v\n", err)
		return
	}

	fmt.Printf("转换成功啦！输出文件: %s\n", pngPath)
}
